source("./src/calculate_gev_cdf.R")
source("./src/calculate_gev_mixture_model_cdf.R")
source("./src/find_threshold_associated_with_given_block_size.R")
source("./src/get_provided_covariates.R")
source("./src/get_knn.R")
estimate_ns_gev_mixture_model_automatic_weights_mw <- function(gev_models,
single_ns_gev_model,
covariates = NULL,
k = 50,
maximum_iterations = 1500,
trace = TRUE,
use_extremal_index = TRUE,
use_lower_threshold = FALSE){
# gev_models: an object associated with a result of the function "estimate_several_gev_models()"
# single_ns_gev_model: an object associated with a result of the function "estimate_single_ns_gev_model()"
# covariates: a named list whose names match the fitted model parameter names,
# k: the maximum number of nearest neighbors to search
# maximum_iterations: maximum number of iterations
# trace: boolean value which indicates whether to print information on the progress of optimization
# use_extremal_index: a boolean which indicates whether to use the estimates extremal indexes or not
# use_lower_threshold: a boolean which indicates whether to use threshold associated with the smallest or largest block size
# create an empty output object
output <- list()
# get the normalized gev parameters
if (use_extremal_index){
normalized_gev_parameters <- gev_models$full_normalized_gev_parameters_object
}
else{
normalized_gev_parameters <- gev_models$normalized_gev_parameters_object
}
shapes <- normalized_gev_parameters$shape_star
scales <- normalized_gev_parameters$scale_star
locations <- normalized_gev_parameters$loc_star
# extract the largest data to use
x <- gev_models$data
block_sizes <- gev_models$block_sizes
if (use_lower_threshold){
block_size <- min(block_sizes)
}
else{
block_size <- max(block_sizes)
}
threshold <- find_threshold_associated_with_given_block_size(x, block_size)
y <- x[x > threshold]
# estimate the empirical distribution function
provided_covariates <- get_provided_covariates(single_ns_gev_model = single_ns_gev_model, covariates = covariates)
provided_covariates_knn <- get_knn(data = provided_covariates$used_gev_model_covariates,
k = k,
query = provided_covariates$provided_gev_model_covariates)
x_knn <- x[provided_covariates_knn$id[1, ]]
Fn <- ecdf(x_knn)
# get the number of gev models
p <- nrow(normalized_gev_parameters)
# define the constraints on the unknown weights
lower <- rep(0, p)
upper <- rep(1, p)
# define an initial vector of weights
initial_weights <- rep(1, p)/p
# define the error function to optimize
nlf <- function(w, y){
theoretical_cdf <- calculate_gev_mixture_model_cdf(q = y, locations, scales, shapes, weights = w)
empirical_cdf <- Fn(y)
errors <- (theoretical_cdf - empirical_cdf)^2
loss <- sum(errors)
loss
}
# define the gradient of error function to optimize
nlf_gradient <- function(w, y){
theoretical_cdf <- calculate_gev_mixture_model_cdf(q = y, locations, scales, shapes, weights = w)
empirical_cdf <- Fn(y)
errors <- theoretical_cdf - empirical_cdf
gradient_object <- sapply(1:p, function(j) errors*theoretical_cdf*log(calculate_gev_cdf(q = y,
loc = locations[j],
scale = scales[j],
shape = shapes[j])))
gradient <- 2*apply(gradient_object, 2, sum)
gradient
}
# minimize the error function
answer <- BB::BBoptim(par = initial_weights,
fn = nlf,
gr = nlf_gradient,
y = y,
lower = lower,
upper = upper,
project = "projectLinear",
projectArgs = list(A = matrix(1, nrow = 1, ncol = p), b = 1, meq = 1),
control = list(maximize = FALSE,
trace = trace,
maxit = maximum_iterations,
# ftol = 1.e-10,
# gtol = 1e-5,
# eps = 1e-7,
# maxfeval = 10000,
# triter = 10,
checkGrad = FALSE))
automatic_weights <- answer$par
names(automatic_weights) <- block_sizes
# update the output object
output[["automatic_weights"]] <- automatic_weights
output[["function_value"]] <- answer$value
output[["gradient_value"]] <- answer$gradient
output[["function_reduction"]] <- answer$fn.reduction
output[["number_iterations"]] <- answer$iter
output[["convergence"]] <- answer$convergence
output[["message"]] <- answer$message
output
}
source("./src/estimate_several_gev_models.R")
source("./src/find_minimum_block_size.R")
source("./src/find_block_size_associated_with_given_number_of_blocks.R")
source("./src/generate_gev_sample.R")
source("./src/plot_several_standardized_block_maxima_mean.R")
source("./src/estimate_several_standardized_block_maxima_mean.R")
x <- generate_gev_sample(n = 1000, loc = 1, scale = 0.5, shape = -0.2)
minimum_block_size <- find_minimum_block_size(x)
minimum_block_size
maximum_block_size <- find_block_size_associated_with_given_number_of_blocks(x, m = 50)
maximum_block_size
block_sizes <- seq(from = minimum_block_size, to = maximum_block_size, by = 1)
block_sizes
equivalent_block_sizes_object<- estimate_several_standardized_block_maxima_mean(x, block_sizes, confidence_level = 0.95)
equivalent_block_sizes <- as.numeric(rownames(equivalent_block_sizes_object$selected))
equivalent_block_sizes
rejected_block_sizes <- as.numeric(rownames(equivalent_block_sizes_object$rejected))
rejected_block_sizes
gev_models <- estimate_several_gev_models(x, block_sizes = equivalent_block_sizes, nsloc = NULL)
gev_models <- estimate_several_gev_models(x, block_sizes = equivalent_block_sizes)
names(gev_models)
source("./src/extract_nlargest_sample.R")
source("./src/get_candidate_block_sizes.R")
source("./src/estimate_several_ns_gev_models.R")
source("./src/predict_several_gev_models.R")
source("./src/estimate_gev_mixture_model_identic_weights.R")
source("./src/estimate_gev_mixture_model_pessimistic_weights.R")
source("./src/estimate_several_ns_standardized_block_maxima_mean.R")
source("./src/estimate_gev_mixture_model_automatic_weights_mw.R")
source("./src/estimate_gev_mixture_model_automatic_weights_pw.R")
source("./src/estimate_gev_mixture_model_automatic_weights_mw_log.R")
source("./src/estimate_gev_mixture_model_automatic_weights_pw_log.R")
predict_gev_mixture_model_parameters <- function(x,
data = NULL,
location.fun = ~1,
scale.fun = ~1,
shape.fun = ~1,
use.phi = FALSE,
covariates = NULL,
k = 50,
block_sizes = NULL,
minimum_nblocks = 50,
threshold = NULL,
nlargest = Inf,
confidence_level = 0.95,
use_extremal_index = TRUE,
use_lower_threshold = FALSE,
maximum_iterations = 1500,
log_mv = TRUE,
log_pw = TRUE,
trace = TRUE,
method = c("MLE", "GMLE")[1]){
# x: vector of observations
# data: dataframe of covariates for linear modeling of the gev model parameters
# location.fun, scale.fun, shape.fun: formula describing a model for each parameter using columns from data. data
#                                     must be supplied if any of these arguments are anything other than ~ 1.
# use.phi: boolean which indicates whether to use the log of the scale parameter in numerical optimization
# covariates: a named list whose names match the fitted model parameter names
# k: the maximum number of nearest neighbors to search
# block_sizes: vector containing the sizes of blocks to consider
# trace: boolean value which indicates whether to print information on the progress of optimization
# log_mv: a boolean which indicates whether the model wise loss function is at logarithmic scale or not
# log_pw: a boolean which indicates whether the parameter wise loss function is at logarithmic scale or not
# nlargest: number of largest values to focus on. Note that the whole vector x is used unless, nlargest != Inf.
# maximum_iterations: maximum number of iterations
# threshold: lower bound of block maxima
# use_extremal_index: a boolean which indicates whether to use the estimates extremal indexes or not
# use_lower_threshold: a boolean which indicates whether to use threshold associated with the smallest or largest block size
# confidence_level: desired confidence level when extraction equivalent block sizes.
#                   Note that this value is ignored if block_sizes != NULL.
# minimum_nblocks: desired minimum number of blocks. Note that this number is used to infer the largest block size.
#                  Moreover, this number is ignored if block_sizes != NULL.
# method: estimation method to use
# create an empty output object
output <- list()
# extract the sample of largest values to use
data_largest <- extract_nlargest_sample(x, n = nlargest)
# extract covariates associated with the sample of largest values
data_largest_positions <- which(x >= min(data_largest))
data_largest_covariates <- data[data_largest_positions, ]
# get candidate block sizes
if (is.null(block_sizes)){
block_sizes <- get_candidate_block_sizes(x = data_largest, threshold = threshold, m = minimum_nblocks)
}
# get equivalent block sizes
equivalent_block_sizes_object <- estimate_several_ns_standardized_block_maxima_mean(x = data_largest,
block_sizes = block_sizes,
confidence_level = confidence_level,
data = data_largest_covariates,
location.fun = location.fun,
scale.fun = scale.fun,
shape.fun = shape.fun,
use.phi = use.phi,
method = method)
equivalent_block_sizes <- as.numeric(rownames(equivalent_block_sizes_object$selected))
# get eventual rejected block sizes
rejected_block_sizes <- as.numeric(rownames(equivalent_block_sizes_object$rejected))
# estimate several non-stationary gev models associated with the equivalent block sizes
several_ns_gev_models <- estimate_several_ns_gev_models(x = data_largest,
block_sizes = equivalent_block_sizes,
data = data_largest_covariates,
location.fun = location.fun,
scale.fun = scale.fun,
shape.fun = shape.fun,
use.phi = use.phi,
method = method)
# extract non-stationary gev parameters associated with the equivalent block sizes
several_ns_gev_parameters <- sapply(several_ns_gev_models, function(single_ns_gev_model)
single_ns_gev_model$gev_model$results$par)
several_ns_gev_parameters <- data.frame(t(several_ns_gev_parameters))
# estimate several stationary gev models associated with the equivalent block sizes
gev_models <- predict_several_gev_models(several_ns_gev_models = several_ns_gev_models,
covariates = covariates,
method = method)
# get all gev models
gev_models_object <- gev_models$gev_models_object
# get the block maxima
block_maxima_object <- gev_models$block_maxima_object
# get the block maxima indexes
block_maxima_indexes_object <- gev_models$block_maxima_indexes_object
# get the extremal indexes
extremal_indexes <- gev_models$extremal_indexes
# estimate the identic weights
identic_weights_mw <- estimate_gev_mixture_model_identic_weights(gev_models = gev_models,
use_extremal_index = use_extremal_index)
# estimate the pessimistic weights
pessimistic_weights_object <- estimate_gev_mixture_model_pessimistic_weights(gev_models = gev_models,
use_extremal_index = use_extremal_index)
pessimistic_weights_mw <- pessimistic_weights_object$pessimistic_weights
# estimate model wise automatic weights
if (log_mv){
automatic_weights_mw_object <- estimate_gev_mixture_model_automatic_weights_mw_log(gev_models = gev_models,
single_ns_gev_model = several_ns_gev_models[[1]],
covariates = covariates,
k = k,
maximum_iterations = maximum_iterations,
trace = trace,
use_extremal_index = use_extremal_index,
use_lower_threshold = use_lower_threshold)
}
else{
automatic_weights_mw_object <- estimate_gev_mixture_model_automatic_weights_mw(gev_models = gev_models,
single_ns_gev_model = several_ns_gev_models[[1]],
covariates = covariates,
k = k,
maximum_iterations = maximum_iterations,
trace = trace,
use_extremal_index = use_extremal_index,
use_lower_threshold = use_lower_threshold)
}
automatic_weights_mw <- automatic_weights_mw_object$automatic_weights
automatic_weights_mw_statistics <- list(function_value = automatic_weights_mw_object$function_value,
gradient_value = automatic_weights_mw_object$gradient_value,
function_reduction = automatic_weights_mw_object$function_reduction,
number_iterations = automatic_weights_mw_object$number_iterations,
convergence = automatic_weights_mw_object$convergence,
message = automatic_weights_mw_object$message)
# estimate parameter wise automatic weights
if (log_pw){
automatic_weights_pw_object <- estimate_gev_mixture_model_automatic_weights_pw_log(gev_models = gev_models,
single_ns_gev_model = several_ns_gev_models[[1]],
covariates = covariates,
k = k,
maximum_iterations = maximum_iterations,
trace = trace,
use_extremal_index = use_extremal_index,
use_lower_threshold = use_lower_threshold)
}
else{
automatic_weights_pw_object <- estimate_gev_mixture_model_automatic_weights_pw(gev_models = gev_models,
single_ns_gev_model = several_ns_gev_models[[1]],
covariates = covariates,
k = k,
maximum_iterations = maximum_iterations,
trace = trace,
use_extremal_index = use_extremal_index,
use_lower_threshold = use_lower_threshold)
}
automatic_weights_pw_statistics <- list(function_value = automatic_weights_pw_object$function_value,
gradient_value = automatic_weights_pw_object$gradient_value,
function_reduction = automatic_weights_pw_object$function_reduction,
number_iterations = automatic_weights_pw_object$number_iterations,
convergence = automatic_weights_pw_object$convergence,
message = automatic_weights_pw_object$message)
# get the normalized gev model parameters
normalized_gev_parameters_object <- gev_models$normalized_gev_parameters_object
# get the normalized gev model parameters
full_normalized_gev_parameters_object <- gev_models$full_normalized_gev_parameters_object
# calculate the identic weighted normalized gev model parameters
identic_weighted_normalized_gev_parameters_object <- apply(normalized_gev_parameters_object, 2, mean)
# calculate the pessimistic weighted normalized gev model parameters
pessimistic_weights_pw_shape <- pessimistic_weights_object$pessimistic_weights_shape
pessimistic_weights_pw_scale <- pessimistic_weights_object$pessimistic_weights_scale
pessimistic_weights_pw_loc <- pessimistic_weights_object$pessimistic_weights_loc
pessimistic_weighted_normalized_gev_parameters_object <- c(sum(pessimistic_weights_pw_loc*normalized_gev_parameters_object$loc_star),
sum(pessimistic_weights_pw_scale*normalized_gev_parameters_object$scale_star),
sum(pessimistic_weights_pw_shape*normalized_gev_parameters_object$shape_star))
# calculate the automatic weighted normalized gev model parameters
automatic_weights_pw_shape <- automatic_weights_pw_object$automatic_weights_shape
automatic_weights_pw_scale <- automatic_weights_pw_object$automatic_weights_scale
automatic_weights_pw_loc <- automatic_weights_pw_object$automatic_weights_loc
automatic_weighted_normalized_gev_parameters_object <- c(sum(automatic_weights_pw_loc*normalized_gev_parameters_object$loc_star),
sum(automatic_weights_pw_scale*normalized_gev_parameters_object$scale_star),
sum(automatic_weights_pw_shape*normalized_gev_parameters_object$shape_star))
# calculate the weighted normalized gev model parameters
weighted_normalized_gev_parameters_object <- data.frame(rbind(identic_weighted_normalized_gev_parameters_object,
pessimistic_weighted_normalized_gev_parameters_object,
automatic_weighted_normalized_gev_parameters_object))
names(weighted_normalized_gev_parameters_object) <- names(normalized_gev_parameters_object)
rownames(weighted_normalized_gev_parameters_object) <- c("identic_weights", "pessimistic_weights", "automatic_weights")
# update the output object
output[["data"]] <- x
output[["data_largest"]] <- data_largest
output[["use_lower_threshold"]] <- use_lower_threshold
output[["block_sizes"]] <- block_sizes
output[["equivalent_block_sizes"]] <- equivalent_block_sizes
output[["rejected_block_sizes"]] <- rejected_block_sizes
output[["block_maxima_object"]] <- block_maxima_object
output[["block_maxima_indexes_object"]] <- block_maxima_indexes_object
output[["gev_models_object"]] <- gev_models_object
output[["extremal_indexes"]] <- extremal_indexes
output[["normalized_gev_parameters_object"]] <- normalized_gev_parameters_object
output[["full_normalized_gev_parameters_object"]] <- full_normalized_gev_parameters_object
output[["weighted_normalized_gev_parameters_object"]] <- weighted_normalized_gev_parameters_object
output[["several_ns_gev_models"]] <- several_ns_gev_models
output[["several_ns_gev_parameters"]] <- several_ns_gev_parameters
output[["identic_weights_mw"]] <- identic_weights_mw
output[["pessimistic_weights_mw"]] <- pessimistic_weights_mw
output[["pessimistic_weights_pw_shape"]] <- pessimistic_weights_pw_shape
output[["pessimistic_weights_pw_scale"]] <- pessimistic_weights_pw_scale
output[["pessimistic_weights_pw_loc"]] <- pessimistic_weights_pw_loc
output[["automatic_weights_mw"]] <- automatic_weights_mw
output[["automatic_weights_mw_statistics"]] <- automatic_weights_mw_statistics
output[["automatic_weights_pw_shape"]] <- automatic_weights_pw_shape
output[["automatic_weights_pw_scale"]] <- automatic_weights_pw_scale
output[["automatic_weights_pw_loc"]] <- automatic_weights_pw_loc
output[["automatic_weights_pw_statistics"]] <- automatic_weights_pw_statistics
output
}
