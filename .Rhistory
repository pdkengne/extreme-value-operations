empirical_cdf <- Fn(y)
errors <- log(theoretical_cdf) - log(empirical_cdf)
gradient_object <- sapply(1:p, function(j) errors*log(calculate_gev_cdf(q = y,
loc = locations[j],
scale = scales[j],
shape = shapes[j])))
gradient <- 2*apply(gradient_object, 2, sum)
gradient
}
# minimize the error function
answer <- BB::BBoptim(par = initial_weights,
fn = nlf,
gr = nlf_gradient,
y = y,
lower = lower,
upper = upper,
project = "projectLinear",
projectArgs=list(A = matrix(1, nrow = 1, ncol = p), b = 1, meq = 1),
control = list(maximize = FALSE,
trace = trace,
maxit = maximum_iterations,
# ftol = 1.e-10,
# gtol = 1e-5,
# eps = 1e-7,
# maxfeval = 10000,
# triter = 10,
checkGrad = FALSE))
automatic_weights <- answer$par
names(automatic_weights) <- block_sizes
# update the output object
output[["automatic_weights"]] <- automatic_weights
output[["function_value"]] <- answer$value
output[["gradient_value"]] <- answer$gradient
output[["function_reduction"]] <- answer$fn.reduction
output[["number_iterations"]] <- answer$iter
output[["convergence"]] <- answer$convergence
output[["message"]] <- answer$message
output
}
x <- rnorm(n = 1000)
minimum_block_size <- find_minimum_block_size(x)
minimum_block_size
maximum_block_size <- find_block_size_associated_with_given_number_of_blocks(x, m = 50)
maximum_block_size
block_sizes <- seq(from = minimum_block_size, to = maximum_block_size, by = 1)
equivalent_block_sizes_object<- estimate_several_standardized_block_maxima_mean(x, block_sizes, confidence_level = 0.95)
equivalent_block_sizes <- as.numeric(rownames(equivalent_block_sizes_object$selected))
gev_models <- estimate_several_gev_models(x, block_sizes = equivalent_block_sizes, nsloc = NULL)
results <- estimate_gev_mixture_model_automatic_weights_mw_log(gev_models, trace = TRUE)
source("./src/calculate_gev_cdf.R")
source("./src/find_threshold_associated_with_given_block_size.R")
estimate_gev_mixture_model_automatic_weights_pw <- function(gev_models,
maximum_iterations = 1500,
trace = TRUE,
use_extremal_index = TRUE){
# gev_models: an object associated with a result of the function "estimate_several_gev_models()"
# maximum_iterations: maximum number of iterations
# trace: boolean value which indicates whether to print information on the progress of optimization
# use_extremal_index: a boolean which indicates whether to use the estimates extremal indexes or not
# create an empty output object
output <- list()
# get the normalized gev parameters
if (use_extremal_index){
normalized_gev_parameters <- gev_models$full_normalized_gev_parameters_object
}
else{
normalized_gev_parameters <- gev_models$normalized_gev_parameters_object
}
shapes <- normalized_gev_parameters$shape_star
scales <- normalized_gev_parameters$scale_star
locations <- normalized_gev_parameters$loc_star
# extract the largest data to use
x <- gev_models$data
block_sizes <- gev_models$block_sizes
block_size <- max(block_sizes)
threshold <- find_threshold_associated_with_given_block_size(x, block_size)
y <- x[x > threshold]
# estimate the empirical distribution function
Fn <- ecdf(x)
# get the number of gev models
p <- nrow(normalized_gev_parameters)
# define the constraints on the unknown weights
lower <- rep(0, 3*p)
upper <- rep(1, 3*p)
# define an initial vector of weights
initial_weights <- rep(1, 3*p)/p
# define the error function to optimize
nlf <- function(w, y){
weights_shape <- w[1:p]
weights_scale <- w[(p+1):(2*p)]
weights_location <- w[(2*p+1):(3*p)]
shape <- sum(weights_shape*shapes)
scale <- sum(weights_scale*scales)
location <- sum(weights_location*locations)
theoretical_cdf <- calculate_gev_cdf(q = y, loc = location, scale = scale, shape = shape)
empirical_cdf <- Fn(y)
errors <- (theoretical_cdf - empirical_cdf)^2
loss <- sum(errors)
loss
}
# minimize the error function
data_A <- c(rep(1, p), rep(0, p), rep(0, p),
rep(0, p), rep(1, p), rep(0, p),
rep(0, p), rep(0, p), rep(1, p))
matrix_A <- matrix(data = data_A, nrow = 3, ncol = 3*p, byrow = TRUE)
b <- c(1, 1, 1)
meq <- 3
answer <- BB::BBoptim(par = initial_weights,
fn = nlf,
y = y,
lower = lower,
upper = upper,
project = "projectLinear",
projectArgs = list(A = matrix_A, b = b, meq = meq),
control = list(maximize = FALSE,
trace = trace,
maxit = maximum_iterations,
# ftol = 1.e-10,
# gtol = 1e-5,
# eps = 1e-7,
# maxfeval = 10000,
# triter = 10,
checkGrad = FALSE))
# extract the weights associated with each of the gev model parameters
automatic_weights_shape <- answer$par[1:p]
names(automatic_weights_shape) <- block_sizes
automatic_weights_scale <- answer$par[(p+1):(2*p)]
names(automatic_weights_scale) <- block_sizes
automatic_weights_loc <- answer$par[(2*p+1):(3*p)]
names(automatic_weights_loc) <- block_sizes
# update the output object
output[["automatic_weights_shape"]] <- automatic_weights_shape
output[["automatic_weights_scale"]] <- automatic_weights_scale
output[["automatic_weights_loc"]] <- automatic_weights_loc
output[["function_value"]] <- answer$value
output[["gradient_value"]] <- answer$gradient
output[["function_reduction"]] <- answer$fn.reduction
output[["number_iterations"]] <- answer$iter
output[["convergence"]] <- answer$convergence
output[["message"]] <- answer$message
output
}
rejected_block_sizes
results <- estimate_gev_mixture_model_automatic_weights_pw(gev_models, trace = TRUE, use_extremal_index = TRUE)
results
names(results)
sum(results$automatic_weights_shape)
sum(results$automatic_weights_scale)
sum(results$automatic_weights_loc)
results <- estimate_gev_mixture_model_automatic_weights_pw_log(gev_models, trace = TRUE, use_extremal_index = TRUE)
source("./src/calculate_gev_cdf.R")
source("./src/find_threshold_associated_with_given_block_size.R")
estimate_gev_mixture_model_automatic_weights_pw_log <- function(gev_models,
maximum_iterations = 1500,
trace = TRUE,
use_extremal_index = TRUE){
# gev_models: an object associated with a result of the function "estimate_several_gev_models()"
# maximum_iterations: maximum number of iterations
# trace: boolean value which indicates whether to print information on the progress of optimization
# use_extremal_index: a boolean which indicates whether to use the estimates extremal indexes or not
# create an empty output object
output <- list()
# get the normalized gev parameters
if (use_extremal_index){
normalized_gev_parameters <- gev_models$full_normalized_gev_parameters_object
}
else{
normalized_gev_parameters <- gev_models$normalized_gev_parameters_object
}
shapes <- normalized_gev_parameters$shape_star
scales <- normalized_gev_parameters$scale_star
locations <- normalized_gev_parameters$loc_star
# extract the largest data to use
x <- gev_models$data
block_sizes <- gev_models$block_sizes
block_size <- max(block_sizes)
threshold <- find_threshold_associated_with_given_block_size(x, block_size)
y <- x[x > threshold]
# estimate the empirical distribution function
Fn <- ecdf(x)
# get the number of gev models
p <- nrow(normalized_gev_parameters)
# define the constraints on the unknown weights
lower <- rep(0, 3*p)
upper <- rep(1, 3*p)
# define an initial vector of weights
initial_weights <- rep(1, 3*p)/p
# define the error function to optimize
nlf <- function(w, y){
weights_shape <- w[1:p]
weights_scale <- w[(p+1):(2*p)]
weights_location <- w[(2*p+1):(3*p)]
shape <- sum(weights_shape*shapes)
scale <- sum(weights_scale*scales)
location <- sum(weights_location*locations)
theoretical_cdf <- calculate_gev_cdf(q = y, loc = location, scale = scale, shape = shape)
empirical_cdf <- Fn(y)
errors <- (log(theoretical_cdf) - log(empirical_cdf))^2
loss <- sum(errors)
loss
}
# minimize the error function
data_A <- c(rep(1, p), rep(0, p), rep(0, p),
rep(0, p), rep(1, p), rep(0, p),
rep(0, p), rep(0, p), rep(1, p))
matrix_A <- matrix(data = data_A, nrow = 3, ncol = 3*p, byrow = TRUE)
b <- c(1, 1, 1)
meq <- 3
answer <- BB::BBoptim(par = initial_weights,
fn = nlf,
y = y,
lower = lower,
upper = upper,
project = "projectLinear",
projectArgs = list(A = matrix_A, b = b, meq = meq),
control = list(maximize = FALSE,
trace = trace,
maxit = maximum_iterations,
# ftol = 1.e-10,
# gtol = 1e-5,
# eps = 1e-7,
# maxfeval = 10000,
# triter = 10,
checkGrad = FALSE))
# extract the weights associated with each of the gev model parameters
automatic_weights_shape <- answer$par[1:p]
names(automatic_weights_shape) <- block_sizes
automatic_weights_scale <- answer$par[(p+1):(2*p)]
names(automatic_weights_scale) <- block_sizes
automatic_weights_loc <- answer$par[(2*p+1):(3*p)]
names(automatic_weights_loc) <- block_sizes
# update the output object
output[["automatic_weights_shape"]] <- automatic_weights_shape
output[["automatic_weights_scale"]] <- automatic_weights_scale
output[["automatic_weights_loc"]] <- automatic_weights_loc
output[["function_value"]] <- answer$value
output[["gradient_value"]] <- answer$gradient
output[["function_reduction"]] <- answer$fn.reduction
output[["number_iterations"]] <- answer$iter
output[["convergence"]] <- answer$convergence
output[["message"]] <- answer$message
output
}
results <- estimate_gev_mixture_model_automatic_weights_pw_log(gev_models, trace = TRUE, use_extremal_index = TRUE)
results
names(results)
sum(results$automatic_weights_shape)
sum(results$automatic_weights_scale)
sum(results$automatic_weights_loc)
source("./src/extract_nlargest_sample.R")
source("./src/get_candidate_block_sizes.R")
source("./src/estimate_several_gev_models.R")
source("./src/estimate_gev_mixture_model_identic_weights.R")
source("./src/estimate_gev_mixture_model_pessimistic_weights.R")
source("./src/estimate_several_standardized_block_maxima_mean.R")
source("./src/estimate_gev_mixture_model_automatic_weights_mw.R")
source("./src/estimate_gev_mixture_model_automatic_weights_pw.R")
source("./src/estimate_gev_mixture_model_automatic_weights_mw_log.R")
source("./src/estimate_gev_mixture_model_automatic_weights_pw_log.R")
estimate_gev_mixture_model_parameters <- function(x,
nsloc = NULL,
std.err = FALSE,
block_sizes = NULL,
minimum_nblocks = 50,
threshold = NULL,
nlargest = Inf,
confidence_level = 0.95,
use_extremal_index = TRUE,
maximum_iterations = 1500,
log_mv = TRUE,
log_pw = TRUE,
trace = TRUE){
# x: vector of observations
# block_sizes: vector containing the sizes of blocks to consider
# nsloc: dataframe of covariates for linear modeling of the location parameter
# trace: boolean value which indicates whether to print information on the progress of optimization
# std.err: a boolean which indicates whether the standard errors are returned or not
# log_mv: a boolean which indicates whether the model wise loss function is at logarithmic scale or not
# log_pw: a boolean which indicates whether the parameter wise loss function is at logarithmic scale or not
# nlargest: number of largest values to focus on. Note that the whole vector x is used unless, nlargest != Inf.
# maximum_iterations: maximum number of iterations
# threshold: lower bound of block maxima
# use_extremal_index: a boolean which indicates whether to use the estimates extremal indexes or not
# confidence_level: desired confidence level when extraction equivalent block sizes.
#                   Note that this value is ignored if block_sizes != NULL.
# minimum_nblocks: desired minimum number of blocks. Note that this number is used to infer the largest block size.
#                  Moreover, this number is ignored if block_sizes != NULL.
# create an empty output object
output <- list()
# extract the sample of largest values to use
data_largest <- extract_nlargest_sample(x, n = nlargest)
# get candidate block sizes
if (is.null(block_sizes)){
block_sizes <- get_candidate_block_sizes(x = data_largest, threshold = threshold, m = minimum_nblocks)
}
# get equivalent block sizes
equivalent_block_sizes_object<- estimate_several_standardized_block_maxima_mean(x = data_largest,
block_sizes = block_sizes,
confidence_level = confidence_level)
equivalent_block_sizes <- as.numeric(rownames(equivalent_block_sizes_object$selected))
# get eventual rejected block sizes
rejected_block_sizes <- as.numeric(rownames(equivalent_block_sizes_object$rejected))
# estimate several gev models associated with the equivalent block sizes
gev_models <- estimate_several_gev_models(x = data_largest,
block_sizes = equivalent_block_sizes,
nsloc = nsloc)
# get all gev models
gev_models_object <- gev_models$gev_models_object
# get the block maxima
block_maxima_object <- gev_models$block_maxima_object
# get the block maxima indexes
block_maxima_indexes_object <- gev_models$block_maxima_indexes_object
# get the extremal indexes
extremal_indexes <- gev_models$extremal_indexes
# estimate the identic weights
identic_weights_mw <- estimate_gev_mixture_model_identic_weights(gev_models = gev_models,
use_extremal_index = use_extremal_index)
# estimate the pessimistic weights
pessimistic_weights_object <- estimate_gev_mixture_model_pessimistic_weights(gev_models = gev_models,
use_extremal_index = use_extremal_index)
pessimistic_weights_mw <- pessimistic_weights_object$pessimistic_weights
# estimate model wise automatic weights
if (log_mv){
automatic_weights_mw_object <- estimate_gev_mixture_model_automatic_weights_mw_log(gev_models = gev_models,
maximum_iterations = maximum_iterations,
trace = trace,
use_extremal_index = use_extremal_index)
}
else{
automatic_weights_mw_object <- estimate_gev_mixture_model_automatic_weights_mw(gev_models = gev_models,
maximum_iterations = maximum_iterations,
trace = trace,
use_extremal_index = use_extremal_index)
}
automatic_weights_mw <- automatic_weights_mw_object$automatic_weights
automatic_weights_mw_statistics <- list(function_value = automatic_weights_mw_object$function_value,
gradient_value = automatic_weights_mw_object$gradient_value,
function_reduction = automatic_weights_mw_object$function_reduction,
number_iterations = automatic_weights_mw_object$number_iterations,
convergence = automatic_weights_mw_object$convergence,
message = automatic_weights_mw_object$message)
# estimate parameter wise automatic weights
if (log_pw){
automatic_weights_pw_object <- estimate_gev_mixture_model_automatic_weights_pw_log(gev_models = gev_models,
maximum_iterations = maximum_iterations,
trace = trace,
use_extremal_index = use_extremal_index)
}
else{
automatic_weights_pw_object <- estimate_gev_mixture_model_automatic_weights_pw(gev_models = gev_models,
maximum_iterations = maximum_iterations,
trace = trace,
use_extremal_index = use_extremal_index)
}
automatic_weights_pw_statistics <- list(function_value = automatic_weights_pw_object$function_value,
gradient_value = automatic_weights_pw_object$gradient_value,
function_reduction = automatic_weights_pw_object$function_reduction,
number_iterations = automatic_weights_pw_object$number_iterations,
convergence = automatic_weights_pw_object$convergence,
message = automatic_weights_pw_object$message)
# get the normalized gev model parameters
normalized_gev_parameters_object <- gev_models$normalized_gev_parameters_object
# get the normalized gev model parameters
full_normalized_gev_parameters_object <- gev_models$full_normalized_gev_parameters_object
# calculate the identic weighted normalized gev model parameters
identic_weighted_normalized_gev_parameters_object <- apply(normalized_gev_parameters_object, 2, mean)
# calculate the pessimistic weighted normalized gev model parameters
pessimistic_weights_pw_shape <- pessimistic_weights_object$pessimistic_weights_shape
pessimistic_weights_pw_scale <- pessimistic_weights_object$pessimistic_weights_scale
pessimistic_weights_pw_loc <- pessimistic_weights_object$pessimistic_weights_loc
pessimistic_weighted_normalized_gev_parameters_object <- c(sum(pessimistic_weights_pw_loc*normalized_gev_parameters_object$loc_star),
sum(pessimistic_weights_pw_scale*normalized_gev_parameters_object$scale_star),
sum(pessimistic_weights_pw_shape*normalized_gev_parameters_object$shape_star))
# calculate the automatic weighted normalized gev model parameters
automatic_weights_pw_shape <- automatic_weights_pw_object$automatic_weights_shape
automatic_weights_pw_scale <- automatic_weights_pw_object$automatic_weights_scale
automatic_weights_pw_loc <- automatic_weights_pw_object$automatic_weights_loc
automatic_weighted_normalized_gev_parameters_object <- c(sum(automatic_weights_pw_loc*normalized_gev_parameters_object$loc_star),
sum(automatic_weights_pw_scale*normalized_gev_parameters_object$scale_star),
sum(automatic_weights_pw_shape*normalized_gev_parameters_object$shape_star))
# calculate the weighted normalized gev model parameters
weighted_normalized_gev_parameters_object <- data.frame(rbind(identic_weighted_normalized_gev_parameters_object,
pessimistic_weighted_normalized_gev_parameters_object,
automatic_weighted_normalized_gev_parameters_object))
names(weighted_normalized_gev_parameters_object) <- names(normalized_gev_parameters_object)
rownames(weighted_normalized_gev_parameters_object) <- c("identic_weights", "pessimistic_weights", "automatic_weights")
# update the output object
output[["data"]] <- x
output[["data_largest"]] <- data_largest
output[["covariates"]] <- nsloc
output[["block_sizes"]] <- block_sizes
output[["equivalent_block_sizes"]] <- equivalent_block_sizes
output[["rejected_block_sizes"]] <- rejected_block_sizes
output[["block_maxima_object"]] <- block_maxima_object
output[["block_maxima_indexes_object"]] <- block_maxima_indexes_object
output[["gev_models_object"]] <- gev_models_object
output[["extremal_indexes"]] <- extremal_indexes
output[["normalized_gev_parameters_object"]] <- normalized_gev_parameters_object
output[["full_normalized_gev_parameters_object"]] <- full_normalized_gev_parameters_object
output[["weighted_normalized_gev_parameters_object"]] <- weighted_normalized_gev_parameters_object
output[["identic_weights_mw"]] <- identic_weights_mw
output[["pessimistic_weights_mw"]] <- pessimistic_weights_mw
output[["pessimistic_weights_pw_shape"]] <- pessimistic_weights_pw_shape
output[["pessimistic_weights_pw_scale"]] <- pessimistic_weights_pw_scale
output[["pessimistic_weights_pw_loc"]] <- pessimistic_weights_pw_loc
output[["automatic_weights_mw"]] <- automatic_weights_mw
output[["automatic_weights_mw_statistics"]] <- automatic_weights_mw_statistics
output[["automatic_weights_pw_shape"]] <- automatic_weights_pw_shape
output[["automatic_weights_pw_scale"]] <- automatic_weights_pw_scale
output[["automatic_weights_pw_loc"]] <- automatic_weights_pw_loc
output[["automatic_weights_pw_statistics"]] <- automatic_weights_pw_statistics
output
}
source("./src/generate_gev_sample.R")
source("./src/plot_several_standardized_block_maxima_mean.R")
n <- 10000
nlargest <- 1000
# x <- rnorm(n = n)
x <- generate_gev_sample(n = n, loc = 1, scale = 0.5, shape = 0.1)
results <- estimate_gev_mixture_model_parameters(x,
nsloc = NULL,
std.err = FALSE,
block_sizes = NULL,
minimum_nblocks = 50,
threshold = NULL,
nlargest = nlargest,
confidence_level = 0.95,
use_extremal_index = TRUE,
maximum_iterations = 1500,
log_mv = TRUE,
log_pw = TRUE,
trace = TRUE)
#results
names(results)
# get the block sizes
results$block_sizes
# get the extremal indexes
results$extremal_indexes
# get the normalized gev parameters
results$normalized_gev_parameters_object
# get model wise automatic weights
results$automatic_weights_mw
# get the full normalized gev parameters
results$full_normalized_gev_parameters_object
# get model wise automatic weights
results$automatic_weights_mw
# get the weighted normalized gev parameters
results$weighted_normalized_gev_parameters_object
# get the statistics about the estimation of weights
results$automatic_weights_mw_statistics
results$automatic_weights_pw_statistics
# plot the mean standardized block maxima
plot_several_standardized_block_maxima_mean(x = results$data_largest,
block_sizes = results$block_sizes,
confidence_level = 0.95,
equivalent = FALSE,
xlab = "Block Sizes",
ylab = "Estimated Values",
main = "Mean Standardized Block Maxima Plot")
# plot the mean standardized block maxima (only equivalent models)
plot_several_standardized_block_maxima_mean(x = results$data_largest,
block_sizes = results$block_sizes,
confidence_level = 0.95,
equivalent = TRUE,
xlab = "Block Sizes",
ylab = "Estimated Values",
main = "Mean Standardized Block Maxima Plot")
# get the rejected block sizes
results$rejected_block_sizes
n <- 10000
nlargest <- 1000
# x <- rnorm(n = n)
x <- generate_gev_sample(n = n, loc = 1, scale = 0.5, shape = -0.2)
results <- estimate_gev_mixture_model_parameters(x,
nsloc = NULL,
std.err = FALSE,
block_sizes = NULL,
minimum_nblocks = 50,
threshold = NULL,
nlargest = nlargest,
confidence_level = 0.95,
use_extremal_index = TRUE,
maximum_iterations = 1500,
log_mv = TRUE,
log_pw = TRUE,
trace = TRUE)
#results
names(results)
# get model wise automatic weights
results$automatic_weights_mw
# get the weighted normalized gev parameters
results$weighted_normalized_gev_parameters_object
# plot the mean standardized block maxima
plot_several_standardized_block_maxima_mean(x = results$data_largest,
block_sizes = results$block_sizes,
confidence_level = 0.95,
equivalent = FALSE,
xlab = "Block Sizes",
ylab = "Estimated Values",
main = "Mean Standardized Block Maxima Plot")
# plot the mean standardized block maxima (only equivalent models)
plot_several_standardized_block_maxima_mean(x = results$data_largest,
block_sizes = results$block_sizes,
confidence_level = 0.95,
equivalent = TRUE,
xlab = "Block Sizes",
ylab = "Estimated Values",
main = "Mean Standardized Block Maxima Plot")
# get the rejected block sizes
results$rejected_block_sizes
# get the weighted normalized gev parameters
results$weighted_normalized_gev_parameters_object
